%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass[nocopyrightspace]{sigplanconf}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath,color,listings,lstcoq,url}
\usepackage[T1]{fontenc}

\definecolor{ltblue}{rgb}{0,0.4,0.4}
\definecolor{dkblue}{rgb}{0,0.1,0.6}
\definecolor{dkgreen}{rgb}{0,0.35,0}
\definecolor{dkviolet}{rgb}{0.3,0,0.5}
\definecolor{dkred}{rgb}{0.5,0,0}

\begin{document}

\lstset{language=coq, basicstyle=\ttfamily\scriptsize, columns=flexible,
keepspaces=true}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{CONF 'yy}{Month d--d, 20yy, City, ST, Country} 
\copyrightyear{20yy} 
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm} 
\doi{nnnnnnn.nnnnnnn}

\titlebanner{banner above paper title}        % These are ignored unless
\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Formalizing the Honeynet}
\subtitle{Defining and Proving a Rootkit Installation}

\authorinfo{CM Lubinski}
           {DePaul University}
           {cm.lubinski@gmail.com}

\maketitle

\begin{abstract}
Definitions for multiple file formats, "malicious" file names, and forensic
time lines are provided in Coq. These are combined to mimic the types of
evidence given by independent forensics researchers in a Honeynet forensics
competition. The Honeynet examples are then provided in the form of formal
proofs based on these definitions. Along the way, functions for creating
relevant data structures within Coq are also described.
\end{abstract}

\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore, 
% you may leave them out
\terms
term1, term2

\keywords
keyword1, keyword2

\section{Introduction}

After completing a lengthy customs process in the largest airport of
burgeoning global power, you notice that your laptop appears to be running
rather slowly. You begin to suspect that a root-kit has been installed, but
you are uncertain how to prove this. At first, you consider using
off-the-shelf antivirus software to find the infection. The risk of damaging
international relations between your countries is too great when using such
proprietary software, however. What you really need is a concrete definition
of a root kit and evidence fitting that definition to prove that your machine
has been attacked.

This scenario is the ultimate goal of the research provided in this paper. We
need formal (we will use the Coq programming language) definitions for various
types of evidence needed by forensics analysts. We will also need a way to
convert real data (e.g. from a disk image) into these definitions. Combining
these two ideas, we can provide concrete {\em proofs} regarding whether or not
a particular image fits such a definition; in the above example, we could
provide a {\em proof} that a root-kit was installed.

To guide our search, we will focus on the evidence structures and proofs
described by several independent researchers studying a ``Honeynet''
challenge. The Honeynet Project\cite{honeynet}'s now-defunct {\it Scan of the
Month} series provided researchers a disk image attained from a compromised
honeypot (a computer created with the explicit goal of catching malware for
inspection.) Each month, they were challenged to describe what happened to the
system and provide evidence for their conclusions. We will consider one
specific example\cite{honeynet-15}, in which a rootkit was installed on a
server and the security community was asked to recover the rootkit, prove that
it had been installed, and provide a step-by-step writeup describing how the
rootkit was found.

\section{Getting Our Feet Wet with File Types}

We start by considering a relatively straight-forward request: defining what
it means for a given file to be a JPEG. How can we formalize this notion? One
tact (used by many operating systems) is to rely on the file extension (if
present) -- in this case, checking for either {\tt jpg} or {\tt jpeg}. This is
a very loose definition, however, as malicious users would need give their
files a different extension to avoid detection. We could instead review the
JPEG spec and confirm that all of the meta data contained within this file is
consistent with said spec. This approach runs the opposite end of the
spectrum, requiring significantly more evidence. Further, the JPEG spec is not
as tidy as we might hope, and most applications are lenient with the file
formats they accept.

Instead, we will chose a middle route, opting to use ``magic numbers'' as our
guide. This refers to tell-tale byte values at predictable points within the
file data. These file signatures are {\it relatively} unique to various file
formats, so we will use them in our definitions and add additional checks as
necessary. JPEGs happen to always start with the bytes {\tt ff d8} and end
with {\tt ff d9}. Similarly, gzipped files begin with {\tt 1f 8b 08} and Linux
executables (ELFs) begin with {\tt 7f 45 4c 46} ({\tt 7f} E L F).

If we represent each byte as a positive integer, then writing these
definitions in the proof-centric language of Coq (plus some syntactic sugar)
would look like

\begin{lstlisting}
Definition isJpeg (file: File) :=
     file @[  0 ] = value 255
  /\ file @[  1 ] = value 216 
  /\ file @[ -2 ] = value 255
  /\ file @[ -1 ] = value 217.

Definition isGzip (file: File) :=
     file @[ 0 ] = value 31
  /\ file @[ 1 ] = value 139 
  /\ file @[ 2 ] = value 8.

Definition isElf (file: File) :=
     file @[ 0 ] = value 127
  /\ file @[ 1 ] = value 69 
  /\ file @[ 2 ] = value 76
  /\ file @[ 3 ] = value 70.
\end{lstlisting}

For each definition, the first (and, in the case of the JPEG, last) bytes of a
file must both be present (as indicated by {\tt value}) and equal to the byte
sequences described above. We will discuss the absence of byte values later,
but for now, assume that this accounts for ``missing'' evidence. By defining
file types in this manner, we can use these definition as building block
within larger definitions and within proofs. For example, given these
definitions, we can {\it prove} that JPEG files cannot also be gzipped files:

\begin{lstlisting}
Lemma jpeg_is_not_gzip : forall (file: File),
  (isJpeg file) -> ~(isGzip file).
\end{lstlisting}

A full version of this proof (and others mentioned throughout this paper) is
provided in the appendix.

\section{Expanding Definitions with Honeynet Examples}

Let's now consider the Honeynet {\it Scan of the Month} mentioned in the
introduction. In his entry for this contest, Matt 
Borland\cite{borland-honeynet} described a deleted, ``tar/gzipped file
containing the tools necessary for creating a home for the attacker on the
compromised system''. Formalizing this a bit, we will say that he proved that

\begin{lstlisting}
Lemma bordland_honeynet_file:
  exists (file: File),
  (OnDisk file honeynet_image_a)
  /\ isDeleted file
  /\ isGzip file
  /\ exists (filename: list Z),
     (In filename (Tar.fileNamesFrom (gunzip_a file)))
     /\ maliciousLooking filename.
\end{lstlisting}

That's a bit of a mouthful, but we are stating there exists a deleted, gzipped
file on the Honeynet disk image such that, when we unzip the file, the
contained tar includes a malicious-looking file name. Note that both the
Honeynet image and the unzipping operation are prepended with `{\tt \_a}',
which we will use to indicate ``assumption''. We will discuss assumptions in
detail momentarily; we can treat them as another type of definition until
then. We would instead prefer to focus on each of the definition in the and
clause.

\subsection{OnDisk}

How might we define that a file "exists" on a particular disk image? For a
simple definition, we could start by claiming a ``file'' is on a disk image if
that file's contents could be found sequentially in the disk. In other words,
we might consider the file to be on disk if we can find a starting index on
the disk such that every byte afterwards matches that of the file.

\begin{lstlisting}
Definition OnDiskTry1 (file: File) (disk: Disk):
  exists (startPosition: Z), forall (i: Z),
  (i >= 0 /\ i < (fileSize file)) -> 
    disk @[ startPosition + i ] = file @[ i ].
\end{lstlisting}

This definition isn't very useful in practice, however, as files are very
often fragmented across multiple segments of a disk image. Moreover, this
definition would also include false positives, where a ``file'' is formed by
looking at the bits that span a fragment boundary. Files are stored on disks
via file systems, which make no sequential guarantees (particularly in recent
file systems such as ZFS and Btrfs).

We must therefore, build our definition for file existence with file systems
in mind. Proving that a file exists within each type of file system is a
relatively unique operation, however. As a result, we will define file
existence as the disjunction of file existence within each file system. While
the definitions are distinct, they each tend to follow the pattern that there
exists some file identifier such that if we were to parse the file associated
with that identifier on the given disk, we would find a file identical to the
provided file.

\begin{lstlisting}
Definition OnDisk (file: File) (disk: Disk):
  (* Ext2 *)
  (exists (inodeIndex: Z):
    (parseFileFromInodeIndex disk inodeIndex) = value file)
  \/ (* FAT32 *)
  (exists (clusterNumber: Z):
    (parseFileFromClusterNumber disk clusterNumber) = value file)
  \/ (* Btrfs *)
  (exists (key: Z):
    (parseFileFromBtrfsKey disk key) = value file)
  \/ ...
\end{lstlisting}





The functions {\tt fileFromINodeIndex}, {\tt fileFromClusterNumber}, and their
ilk are {\it computations} in the sense that we do not, as of yet, give them
as a Propositional definition. Instead, Coq inspects the contents of the disk
and runs through the defined algorithms to build the prerequisite SuperBlock,
GroupDescriptor, etc. structures to create an instance of a File. We will
discuss these computations in more detail momentarily.


\section{Introducing the Honeynet Example}

Evidence of that style, though not formality, serves as the building blocks
for many forensics cases. Consider next an example \cite{honeynet-15} from the
Honeynet Project's now-defunct {\it Scan of the Month} series. Here, a disk
image involved in a rootkit installation was provided to the security
community. These researchers were challenged to recover a deleted rootkit,
prove that said rootkit was installed, and provide a step-by-step writeup
describing how the rootkit was found.

We use the evidence provided by one of the top entrants, Matt Borland
\cite{borland-honeynet}, as a rough outline of the types of evidence we will
need. This evidence included the description of a deleted, ``tar/gzipped file
containing the tools necessary for creating a home for the attacker on the
compromised system''. Borland provided an informal proof that 1) a particular
file existed on the system, that it was 2) a gzipped tar, 3) that it was
deleted, and that 4) the file contained malicious files. Let's consider each
of these pieces of evidence in turn.


\begin{lstlisting}
Definition file_exists (disk: Disk) (file: File):
  (* Ext2 *)
  (exists (inodeIndex: Z), 
    file = (fileFromINodeIndex disk inodeIndex))
  \/ (* FAT32 *)
  (exists (clusterNumber: Z), 
    file = (fileFromClusterNumber disk clusterNumber))
  \/ ...
\end{lstlisting}

The functions {\tt fileFromINodeIndex}, {\tt fileFromClusterNumber}, and their
ilk are {\it computations} in the sense that we do not, as of yet, give them
as a Propositional definition. Instead, Coq inspects the contents of the disk
and runs through the defined algorithms to build the prerequisite SuperBlock,
GroupDescriptor, etc. structures to create an instance of a File. We will
discuss these computations in more detail momentarily.

In the mean time, what does a {\tt File} look like? The {\tt File}s discussed
in this paper are abstract representations common across various file systems.
To that end, their structure is quite light, needing only a file size, a field
indicating whether or not the file is marked as deleted, and a function for
random-accessing bytes within the file. The type signature of the final trait,
named {\tt byteOffset}, indicates that this function returns an {\tt Exc Z},
which is equivalent to an {\it Option} -- this is a way to wrap results where
a failure is possible. If the offset requested is in the file, the result
would be {\tt value byte}, where byte is the byte at that offset. If
requesting an offset outside the bounds of the file, you would receive an {\tt
error}. Note also, that as demonstrated in the examples above, this function
should accept negative values and search from the end of the file.

\begin{lstlisting}
Structure File := mkFile {
  fileSize: Z;
  deleted: boolean;
  byteOffset: Z->Exc Z
}.
\end{lstlisting}

We have now described the definitions for file existence, if a file is a
gzipped-tar, and a simple definition for whether or not a file is deleted. All
that is left is to prove that the provided tgz contains malicious files:

\begin{lstlisting}
Definition borland_malicious_tgz (disk: Disk):
  exists (file: File),
  (file_exists disk file)
  /\ (deleted file) = true
  /\ (isTgz file)
  /\ (tgzContainsMaliciousFiles file).
\end{lstlisting}

Defining what it means for a gzipped-tar file to "contain" malicious files
requires we first introduce some limitation and provide resolving work
arounds.

\section{The Assumption Type}

Coq, as a theorem proving language, has limited applicability for certain
practical applications. Due to its constructive representation of natural
numbers ({\tt nat}), for example, attempting to use this type to represent
"large" numbers as small at 8000 may cause the interpreter to overflow its
heap. This means that we make use of binary-representations for numbers and
use sparse maps to represent disk images. 

Their focus also proofs also leads to a frustrating lack of substantial,
practical library support. Further, there is no foreign function interface
which would allow 


and evidence for this particular competition would complete the proof for

\begin{lstlisting}
Lemma borland_15_proof: 
  (bordland_malicious_tgz honeynet_15_image 23).
\end{lstlisting}

It is important to point out that in Borland's writeup (and in many forensics
papers) the same person is both authoring the {\it definition} of evidence as
well as {\it providing the evidence} itself. This is exactly the problem
discussed above, the sort of biased results we are trying to avoid.

Let's dig into our definition a bit deeper. We start by declaring that there
{\it exists} a file such that the file matches that received from reading
inodes on the disk. This is particular to 

%Note that, while we were given an entire file, we only cared about the initial
%and final bytes. As our definition does not involve any other bytes of the
%image, these bytes could be all zeros, all ones, present, damaged, or
%otherwise. The definition doesn't care, and this is a trait we will use in the
%future to limit the size of our proofs.

\section{Delete INode}

Now, let's consider a more complicated example, that of testing whether a
particular inode index is marked as ``deleted'' in the file system. Note that
there are many possible definitions of ``deleted'' we may choose from. The
ext2 file system has redundant mechanisms to define if a file has been
deleted. We chose one, the allocation bit map. Ultimately, whether or not a
given inode index is marked as deleted involves finding the ``group block''
associated with that index, looking up the bit associated with the index in
the allocation table, and checking whether it is zero (for deleted) or one
(for allocated).

Of course, there is a lot we glossed over. What is a group block? How do we
find the right one? How do we know that the inode index provided is valid? To
answer these questions, we created several additional data structures and
evidence functions.

\section{Future Work}

automatically generate the proof based on disk images; additional types of
evidence; abstractions of file systems


\appendix
\section{Relevant Proofs}

\begin{lstlisting}
Lemma jpeg_is_not_tgz : forall (file: File),
  (isJpeg file) -> ~(isTgz file).
  Proof.
  unfold isTgz, isJpeg.
  intros file jpeg_asmpt.
  destruct jpeg_asmpt as [byte0_is_255].
  rewrite byte0_is_255.
  unfold not. intros contra.
  destruct contra as [not_equal].
  discriminate not_equal.
  Qed.
\end{lstlisting}

\acks

Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.

\begin{thebibliography}{}
\softraggedright

\bibitem{honeynet}
The Honeynet Project. \url{http://www.honeynet.org/}
\bibitem{honeynet-15}
The Honeynet Project \emph{Scan of the Month} \#15.
\url{http://old.honeynet.org/scans/scan15/}
\bibitem{borland-honeynet}
Borland, Matt. Submission to Honeynet.org \emph{Scan of the Month},
05/05/2001. \url{http://old.honeynet.org/scans/scan15/som/som6.txt}

\end{thebibliography}


\end{document}
